---

title: Git 入门
categories: [计算机, 工具]
tags: [git]
authors: [badbadyi]
---

## 简介

### Git 是什么

Git 是一个分布式版本控制工具，你可以用 Git 来存储你的文件，跟踪文件历史，合并更改，亦或是在错误发生时回滚到之前的版本。

### Git 的特点

- 本地执行

  绝大多数 Git 操作都可以在本地直接执行而无需借助网络，这使得 Git 执行迅速且可以离线使用

- 完整性保证

  你无法在 Git 不知情的情况下修改 Git 仓库下的文件内容或是路径结构

- 一般只添加数据

  这使得你可以更轻易的恢复你的数据，而无需担心因为失误操作导致文件损毁

## 安装 Git

### Windows

在 Windows 上安装 Git 可以选择 [Git for Windows](https://gitforwindows.org/)

Git for Windows 有完善的图形化安装界面，如果不需要额外配置，一路下一步即可以完成安装

### 验证安装

打开命令行界面，执行 `git -v` 来查询安装 Git 的版本，如果获得类似于 `git version 2.43.0.windows.1` 的返回值，则说明安装成功

## 必要的配置

### Git 配置简介

Git 通过 `git config` 命令行工具来管理 Git 配置

执行 `git config --list --show-origin` 命令来获取你所有的配置以及其所在的文件路径

其中位于 `.../etc/gitconfig` 路径下的为全局配置，对于 Windows 系统， `...` 指代 Git 安装位置。

其中位于 `~/.gitconfig` 路径下的为用户配置，其中 `~` 指代用户文件夹

每个仓库路径下的 `config` 文件（即 `.git/config`）为仓库配置，仅针对对应 Git 仓库

其中，仓库配置会覆盖用户配置，用户配置会覆盖全局配置

### 首次提交前的配置

Git 每次提交都需要用到用户名和邮箱地址，因此你需要优先配置这两项

配置用户名，将双引号内的字符替换为你的用户名

```sh
git config --global user.name "your name here"
```

配置邮箱，将示例邮箱地址替换为你的邮箱

```sh
git config --global user.email xxxxx@example.com
```

其中 `--global` 参数表示修改全局配置，这个系统上的所有操作都可以用到该配置，避免了使用新仓库时重新配置的麻烦

### 验证配置

通过命令 `git config --list` 来检查你的配置

通过命令 `git config <key>` 来检查特定键值的配置，例如 `git config user.name`

## 基础使用

### Git 仓库

一个 Git 仓库本质上就是一个带有 `.git` 文件夹的路径，该路径下的的文件受到 Git 工具的监控和管理，而 `.git` 文件夹用于来存放管理文件快照和配置文件

### 获得一个仓库

你需要获得一个 Git 仓库来尝试各种 Git 操作

- 本地建立

  通过命令 `git init` 来在当前路径建立一个 Git 仓库（看上去就是生成了一个 `.git` 文件夹）

  对于空文件夹，这样做已经足够了。但是如果你在一个已经有文件的路径下按照该方式建立仓库，你需要使用 `add` 指令来添加你需要追踪的文件，然后使用 `commit` 指令进行第一次提交

  ```sh
  git add *.c
  git add README.md
  git commit -m "init my project"
  ```

- 远程克隆

  你还可以通过命令 `git clone` 来获取一个现成的仓库，下面以本博客源代码为例

  通过如下命令克隆一个仓库到当前路径下的 `badbadyi.github.io.git` 文件夹（根据仓库名生成文件夹）

  ```sh
  git clone git@github.com:badbadyi/badbadyi.github.io.git
  ```

  通过如下命令克隆一个仓库到当前路径下的 `project` 文件夹（自定义目标文件夹）

  ```sh
  git clone git@github.com:badbadyi/badbadyi.github.io.git project
  ```

### 文件的状态

前面提到，Git 可以记录仓库中文件的变化，你可以通过命令 `git status` 来检查仓库文件变化

这个命令会返回如下信息

- 当前所在的分支

- 改动信息

- 未追踪文件

### 暂存文件

当一个被追踪文件被**改动**后，该文件处于**未被暂存的状态**，运行 `git status` 得到类似如下输出

```
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   "\346\265\213\350\257\2251.txt"
```

如果你需要提交一个这样的文件，你可以先使用 `git add <filename>` 命令将其暂存（和添加追踪文件同一个命令）， `<filename>` 指代你需要暂存的文件

你的下一次提交会一并提交你的所有暂存状态的文件

*附：如果你在暂存一个文件之后再对其进行改动，暂存区的文件仍为你使用 `add` 指令时的版本。如果你希望暂存最新的版本，你应该再用一次 `git add`* 

### 提交更新

使用 `git status` 来确保你需要提交的改动都已经被暂存

然后使用 `git commit` 指令来提交更新

这个指令会让你跳转到你配置的编辑器，第一行为空行用于你编写你的提交信息，后面的行都被注释，记录了你这次将要提交的相关信息，在完成提交时他们会被舍弃

你可以为命令加上 `-m` 参数来直接编辑提交信息，而无需进入编辑器，例如

```sh
git commit -m "my first commit"
```

提交成功后会有类似如下信息

```
[master 1d169b8] my first commit
 1 file changed, 1 insertion(+), 1 deletion(-)
```

你还可以通过 `-a` 参数来跳过暂存环节

```sh
git commit -a -m "my first commit"
```

### 忽略文件

有时候你希望 Git 不管理一些文件，又不希望它一直出现在未追踪的文件列表里。例如项目中的日志文件或者编译中的临时文件。

你可以通过编辑 `.gitignore` 文件来忽略他们

该文件以行为单位读取，以 `#` 开头的行会被忽略，下面是一个简单的例子

```
# 忽略 .o 后缀文件 *为通配符
*.o

# 不忽略该文件，即使它在前面被标记为忽略
!dont_ignore.o

# 只忽略当前目录下的 ignore
/ignore

# 忽略所有目录下的该文件夹
build/

# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt

# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
```
{: file='.gitignore'}


根目录下的 `.gitignore` 文件会被应用到所有的目录下，而子目录也可以有该文件，被应用到子目录下的所有文件夹

详细的用法 [github/gitignore: A collection of useful .gitignore templates](https://github.com/github/gitignore)

## 本地分支

### 创建和切换

在当前分支下创建一个新的分支

```sh
git branch <分支名>
```

切换到目标分支（让 `HEAD` 指针指向目标分支）

```sh
git checkout <分支名>
```

假设在 `main` 分支上创建并切换了一个新分支 `test`，修改部分文件后提交更新，`test` 分支会向前推进，而 `main` 分支维持不变

当你重新切回 `main` 时，目录中的文件会回到 `main` 分支的状态

```sh
git branch test
git checkout test
# made some change
git commit -a -m "test move forward" 
git checkout main
```

### 简单合并

假设如下情景，你需要基于一个上线项目的基础开发一项新功能，于是你在 `main` 分支（上线项目的分支）的基础上创建了一个新的分支 `feature` ，在该分支进行开发，而且已经作出了一些提交。

随后，你接到通知，上线项目存在漏洞，需要紧急修补。你不需要删除你的新更改，你只需要切换到 `main` 分支即可回到上线项目的状态。在此基础上创建新分支 `fix` 来修补漏洞

现在项目出现了分叉，`fix` 分支和 `feature` 分支都是基于 `main` 分支发展的不同分支

在你完成 `fix` 分支上的工作后，你会想让 `fix` 分支与 `main` 分支合并，作为新的上线项目分支

```sh
git checkout main
git merge fix
```

因为 `fix` 是基于 `main` 向后发展的分支，所以 `main` 与 `fix` 合并本质上是 `main` 的指针指向了 `fix`

### 合并冲突

在你完成 `feature` 分支上的工作后，你会想让 `main` 与 `feature` 合并，作为新的上线项目分支

```sh
git checkout main
git merge feature
```

此时 `main` 和 `feature` 并没有直接的依赖关系（ `main` 已经与 `fix` 合并，处于不同分叉），Git 将会依据二者的共同祖先快照来生成一个新的快照并且指向它

但是 `fix` 和 `feature` 分支可能会基于同一文件的同一处出现不同的修改，这时合并出现了冲突，Git 会暂停下来等待你解决冲突

冲突发生后，你可以通过 `git status` 来查看因为冲突而没有成功合并的文件

这些文件会被 Git 加入特殊的标记，如下

```
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> feature:index.html
```

冲突被 `<<<<<<<` 、`=======` 、`>>>>>>>` 分为三个部分，`HEAD` 指代当前指针所在位置，等号上下部分分别是对冲突处不同的修改

简单地，你可以通过简单的替换这一整部分代码来解决冲突，例如，替换上面所有代码为如下

```
<div id="footer">contact : email.support@github.com</div>
```

你也可以通过高级的图形化界面工具来解决冲突

### 删除分支

现在合并已经结束，开发的所有新功能已经整合到 `main` 分支中，`feature` 分支已经不被需要，你可以通过如下指令来删除该分支

```sh
git branch -d feature
```

当你通过该命令删除还未合并的分支时会失败（避免你丢失还未合并的工作）

你可以通过 `-D` 参数来强制删除

### 分支管理

直接不带参数地使用 `git branch` 可以获得所有分支，其中，当前分支通过 `*` 标记

参数 `-v` 指令来查看每个分支的最后一次提交（SHA1，提交信息）

参数 `--merged` 来查看已经合并到当前分支的分支

*你可以删除已经合并到当前分支的分支（除了被 `*` 标记的分支），而无需担心会影响到你的工作，因为它们已经被整合到当前分支了，所以你不会丢失任何东西*

参数 `--no-merged` 来查看还未合并到当前分支的分支

### 总结

把每一次提交之后的的快照看作对象，把每个分支看作指针，此外还有特殊的 `HEAD` 指针来指向当前所在的位置

每次提交都会在之前对象的基础上创建一个新的对象，并将当前分支的指针移到新的对象上

合并分支时

- 若一个分支的对象是另一个分支对象的直接祖先，则直接将祖先对象的指针移动到新对象上
- 若两个分支没有直接联系，则依据二者的共同祖先生成一个新的对象，这种情况下可能产生合并冲突（即两个分支对同一文件同一位置进行了不同的修改）

分支相关基础指令

- 创建新分支 

  `git branch <分支名>`

- 删除分支

  `git branch -d <分支名>`

- 切换分支到

  `git checkout <分支名>`

- 合并目标分支到当前分支

  `git merge <分支名>`

## 远程分支

### 引入

当你从一个远程服务器克隆 Git 仓库，`clone` 命令会自动命名一个 `origin` 远程分支，它将会指向和 `main` 分支同一个对象，并且在本地命名为 `origin/main`，你可以基于这个分支继续开发

在你克隆之后进行开发的同时，另一台电脑上也可能同时在做另一项开发，且已经提交了代码到服务器，这时代码产生了分叉（远端的 `origin/main` 和本地的 `main` 处于不同的分叉上）

你可以通过 `git fetch <远端名>` （本例中远端名为 `origin`）来将服务器上的分支同步到你的本地 

### 推送

通过 `git push <远端名> <本地分支名>` 来将本地的工作推送到服务器，例如 `git push origin test`

这时如果有人 `clone` 或 `fetch` 该仓库，他们的本地指针会指向服务器的 `test` 分支

*你可能会希望通过设置SSH密钥来避免每次推送时输入账户密码*

### 拉取

通过 `git pull` 你可以抓取服务器上的分支并且尝试合并它

大多数情况下该命令可以等于 `fetch` 命令加上 `merge` 命令

### 删除远程分支

当你和合作者完成了一项工作，并将你们的工作整合到 `master` 后，你可能希望删除开发该工作时所使用的远程分支

通过 `git push <远端名> --delete <需要删除的分支>` 来删除分支

例 `git push origin --delete feature`

